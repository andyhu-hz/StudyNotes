10.3 刷新显示列表项
运行CriminalIntent应用，点击某个列表项，然后修改对应的Crime明细信息。这些修改数据 已保存至模型层，但返回列表后，RecyclerView视图并没有刷新。下面就来处理这个问题。 模型层保存的数据如有变化（或可能发生变化），应通知RecyclerView的Adapter，以便其 及时获取新数据并刷新显示列表项。在恰当的时机，与系统的ActivityManager回退栈协同运 作，可实现列表项的刷新。 CrimeListFragment启动CrimeActivity实例后，CrimeActivity被置于回退栈顶。这导致 原先处于栈顶的CrimeListActivity实例被暂停并停止。 用户点击后退键返回到列表项界面，CrimeActivity随即弹出栈外并被销毁。此时， CrimeListActivity立即重新启动并恢复运行。
CrimeListActivity恢复运行后，操作系统会发出调用onResume()生命周期方法的指令。 CrimeListActivity接到指令后，它的FragmentManager会调用当前被activity托管的fragment 的onResume()方法。这里的fragment就是指CrimeListFragment。  在CrimeListFragment中，覆盖onResume()方法，触发调用updateUI()方法刷新显示列表 项，如代码清单10-9所示。如果已配置好CrimeAdapter，就调用notifyDataSetChanged()方 法来修改updateUI()方法。
 为什么选择覆盖onResume()方法来刷新列表项显示，而不用onStart()方法呢？当有其他 activity位于我们的activity之前时，我们无法确定自己的activity是否会被停止。如果前面的activity 是透明的，我们的activity可能会被暂停。对于此场景下暂停的activity，onStart()方法中的更新 代码是不会起作用的。一般来说，要保证fragment视图得到刷新，在onResume()方法内更新代码 是安全的选择。 运行CriminalIntent应用。选择某个crime项并修改其明细内容。然后返回到列表项界面，可以 看到，列表项已经刷新
