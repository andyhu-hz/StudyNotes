# Activity生命周期     


## 正常情况下的生命周期分析     

### 1. onCreate()     

这是Activity的入口，通常进行一些初始化操作,如`setContentView()`.       

### 2. onRestart()      

当当前Activity从不可见状态重新变为可见状态时，这个回调就会被调用，比如用户点击了Home键回到桌面，这时Activity就会被暂停，也就是onPause和onStop被调用了，当重新打开应用时，Activity就重新可见，调用onRestart方法，或者从当前Activity跳转到一个新的Activity，然后用户返回这个Activity，同样会调用该方法。     

### 3. onStart()      

这个方法标志着Activity已经变为可见状态，但是还没有出现在前台，还不能与用户进行交互。      

### 4. onResume()     

这个方法紧跟在onStart之后，表示Activity已经启动完成，并已到达前台，可以与用户交互，他与onStart最大的区别就是表示Activity是否位于前台。     

### 5. onPause()     

这个方法表示当前Activity暂停，正常情况下，onStop就会接着被调用，这个方法里面可以做一些轻量级的结束操作，比如关闭动画、存储信息，但是不能做耗时操作。       

这是因为，这个方法会影响到新Activity的显示，**只有当前Activity的OnPause()方法执行完后，新Activity的OnResume才会执行，新的Activity才会到达前台与用户交互**。      

### 6. onStop()      

表示Activity即将停止，但是也不能做耗时操作，通常在OnPause之后调用。      

### 7. onDestory()     

表示Activity即将被销毁，这是生命周期中最后一个回调，可以做回收和结束操作。     

### 注意      

* 只有旧Activity的OnPause执行完，新Activity的OnResume才会执行        

* 如果用户打开新Activity或者回到桌面时，回调如下:onPause -> onStop,有一种特殊情况，如果新的Activity采用了透明(Alpha)主题，则不会回调onStop。          

### 一种保存Activity状态的方法**onSaveInstanceState(Bundle outState)**    
如果一个应用发生设备旋转，会导致当前Activity销毁和重建，这时需要保存一下Activity的状态，并在Activity重建后恢复原状态        


* 介绍该方法     

 * 该方法通常在onPause(),onStop(),onDestory()方法之前由系统调用     
 * 该方法默认实现要求所有activity视图将自身状态数据保存在Bundle对象中(Bundle是存储字符串键与限定类型值之间映射关系的(键对值)的一种结构)      
 在onCreate(Bundle savedInstanceState)方法中作为参数传入       
 ```java
 @Qverride
 public void onCreate(Bundle savedInstanceState){
   super.onCreate(savedInstanceState);
 }
 ```     
 当我们覆盖onCreate()方法时，我们实际是在调用activity超类的onCreate()方法，并传入收到的bundle，在超类代码中，通过取出保存的视图状态数据，activity的视图层结构得以重新创建       


* 覆盖onSaveInstanceState(Bundle)方法      
先将一些数据保存在bundle中，然后在onCreate()方法中取回数据        

 * 给出一个情景，有一个Button，当点击它一次，它所显示的数据就加一，然后屏幕反转，要原来Button上的数据保存下来     
 * 先建一个常量作为存储在bundle中的键对值的键        
 ```java
 public class TestActivity extends AppCompatActivity {
   private static final String TAG = "TestActivity";
   private static final String KEY_INDEX = "index";
   private int mCurrentIndex = 0;

   private Button mButton;

   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.main);
     Log.v("TAG","onCreate");

     mButton = (Button)findViewById(R.id.mbutton);
     mButton.setOnClickListener(new View.OnClickListener() {
       public void onClick(View v) {
         mCurrentIndex++;
       }
     });
   }
 }
 ```     

 * 然后覆盖onSaveInstanceState()方法，以刚才新建的常量作为键，将mCurrentIndex变量值保存到bundle中     
 ```java
 @Override
 public void onSaveInstanceState(Bundle savedInstanceState) {
   super.onSaveInstanceState(savedInstanceState);
   Log.i(TAG,"onSaveInstanceState");
   savedInstanceState.putInt(KEY_INDEX, mCurrentIndex);
 }
 ```    

 * 最后在onCreate()方法中确认是否成功获取到该值，如果成功，就将它赋值给变量      
 ```java
 if (savedInstanceState != null) {
   mCurrentIndex = savedInstanceState.getInt(KEY_INDEX,0);
 }
 ```       

这下屏幕反转后我们也能保存之前的数据，但是Bundle中存储和恢复的数据只能是基本数据类型(primitive type)以及可以实现Serializable和Parcelable接口的对象     
