# 快速排序    

这个算法被称为20世纪最伟大的算法之一，同归并排序一样具有O(nlogn)的时间复杂度，也是一种高级排序算法。       

## 算法实现     


我们首先从一个数组中选取一个值作为一个标准值(这个值通常选择为数组第一个元素),然后我们进行一些操作，使得数组被划分成两个部分，前半部分的值都小于这个标准值，后半部分的值都大于这个标准值。    

下面看一下图示：    

![](../../image/quicksortfirst.png)   

这就是快速排序的基本思想。   

这一步完成后，我们就需要分别对小于6和大于6的两个子数组进行排序排序，这样一直递归下去我们就能得到排序的结果。   

### Partition操作(核心)

上面介绍了快速排序的基本思想，概括的说就是给数组的第一个值在数组中重新选择一个合适的位置，这也就是快速排序的核心。         

先来定义一下Partition操作的一些索引：    

![](../../image/quicksortone.png)   

* l指向数组的开始，也是此次Partition操作的标准值   

* j指向前后两部分的间隔位置，方便当前处理元素的位置放置，也保存了v的最终位置   

* i指向当前考察的元素。       


如果这时i指向的这个元素e大于v的话，这种情况很简单，只需要把e接在绿色区域中就ok了，然后让i++，处理下一个数据。       

![](../../image/quicksorttwo.png)   

如果这时i指向的这个元素e小于v的话，为了保证v能将前后两部分划分开，这里我们把i指向的值与j索引指向的下一位进行交换(j指向的位置是前后两部分的分界，其实就是前一部分的末尾，所以j的下一位就是后一部分的开始，这里我们把它和处理元素交换，但是这个元素所处的范围并没有改变，仍然处于大于v的范围内)，然后让j++，处理下一个数据。       
