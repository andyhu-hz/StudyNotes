# 归并排序

跟快速排序一样，归并排序也是一种高级排序算法，时间复杂度为O(nlogn)，这里介绍两种归并排序的思路和实现方式。    

## 二分递归方式实现归并排序        

### 划分     

这里采用二分的方式将含有n个数据的原数组层层向下划分，当划分到出n/2个组的时候停止，这时每个组只有1个数据，我们将这n/2个组看作是有序的，下面是划分过程：   

![](../../image/mergesortpart.png)    

这里到第三次划分后，每个组就只有一个元素了。这里可以思考一下，这个3是怎么得来的，我们采用了二分的方式，每次进行这样除以2的划分，划分次数很明显是`log2N`次，所以这样就有一个O(logN)的一个时间复杂度，而且如果这里数组长度n不是2的整数倍的话，这里也会取整为log2N。       

### 归并       

划分完成后，就来进行归并操作了，先看一下图解：     

第一次向上归并：    

![](../../image/mergeone.png)    

这次归并完成后，每组就有了两个数据，并且每个都是有序组，接着以同样的方式进行第二次归并     


第二次向上归并：    

![](../../image/mergetwo.png)     

这样每组就有了四个元素，而且每组都是有序组，接着我们进行最后一次归并    

第三次向上归并：    

![](../../image/mergethree.png)     

最后一次归并后，我们之前划分出来的组都已经消失了，只剩下了一个组，而且是个有序组，我这样描述是不是有一种递归的感觉呢。     

这就是二分归并排序的基本思想。     

上面说到划分过程已经有了一个logN的时间复杂度，这里再思考一下，其实我们对每一层进行归并的时候，我们对每一个元素都进行了访问和比较，我们的数组就有N个元素，所以这里也有O(N)个时间复杂度，再乘上上面划分的层次，所以算法的整体时间复杂度就是O(NlogN)。       


### 归并过程的实现(核心)         

如果上面的你都看懂了，那么我们下面来考虑一个看上去很简单，但实际上并不简单的问题，我们先回到最后一次归并之前的情形：     

![](../../image/mergetwo.png)   

我现在问你，你如何把这两个有序组归并成一个仍然有序的组？    

其实我们每次归并的时候都有这样的一个操作，只是操作的次数不同而已。    

下面来谈一下如何实现这个核心的归并过程：       

我想了一圈发现根本不能通过在原数组上通过交换位置来实现这个过程。     

这里我们需要开辟一个临时空间来辅助我们完成这个过程，有了这个临时空间，我们这个操作就变得很容易了，这也是所有的归并排序方式必须使用的一个方法，也是归并排序的一个缺点，虽然它有着较小的时间复杂度，但是它需要另外的空间才能实现。       


来看一下图解：     

![](../../image/mergemergestart.png)     

这里我们设置了三个索引，上面的一个索引用来指向结果数组，下面的两个索引分别指向两个有序组，因为我们是要对整体进行归并。我们将原数组作为结果数组，将开辟出来的临时数组作为处理数组，下面开始第一次归并操作：    

比较处理数组中的两个索引指向的索引，谁此时指向的值较小，就先把这个较小的值放置到结果数组中，这时，结果数组的索引就可以向后推进一位，准备下一次接受结果，同样，刚才指向较小值的那个索引也可以向后推进一位，准备下一次比较。     

过程就是这样，下面我多来模拟几次加深记忆：    

![](../../image/mergemergeone.png)    

这次操作中，先比较3和1，发现1比较小，所以就把1放到结果数组中，然后结果数组和1所在数组的索引都向后推进了一位。    

![](../../image/mergemergetwo.png)    

这次操作中，先比较3和5，发现3比较小，所以就把3放到结果数组中，然后结果数组和3所在数组的索引都向后推进了一位。       

这样一直进行下去我们就把多个有序组归并成了一个有序组。     
