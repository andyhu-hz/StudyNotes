# 矩阵    

矩阵在许多有庞大的计算量的算法中有着巨大的作用，尤其在描述图像的时候更是常用，矩阵通常使用二维数组表示，但在数值分析中还会遇到一些特殊矩阵，如：对称矩阵、三角矩阵、带状矩阵、稀疏矩阵。这些矩阵如果按照普通矩阵的存储方式来存储的话，就会浪费很多内存空间，所以我们要对他们进行压缩存储。下面来一一介绍他们的存储方式和特点。   


## 对称矩阵及其压缩存储    

当一个矩阵的行列数相等时，称为方阵，如果一个n*n的方阵满足a(ij) = a(ji)，称为对称矩阵，在对称矩阵中，几乎有一半的元素是相同的，所以我们可以以矩阵的对称轴来分界线，只需存储对称轴一端和对称轴上的元素即可。然后访问的时候根据对称性就可以访问到所有的元素，这样就能节省几乎一半的存储空间。    

* 访问元素    
如果采用按行优先的方式存储，可以得出对称矩阵对角线以下部分任意元素a(ij)（i>=j）的存储地址是:`add(a(ij)) = a(00) + ((1+2+3+..+i)+j)*Len`.       
当访问到a(ji)时，采用上述公式计算a(ij)的地址即可。      


## 三角矩阵及其压缩存储    

这种矩阵，其对角线的一端元素都为0，所以分别称为上三角矩阵或下三角矩阵，如果按照普通矩阵的存储方式来存储这种矩阵的话，就会使存储空间中有很多空间存在大量0，所以我们对0值的部分不分配存储空间。      

* 下三角矩阵     
如果是下三角矩阵的话，矩阵中非零的元素的应该为a(ij)（i>=j），同样采用按行优先的方式，可以得到每个元素的存储地址为:`add(ij) = add(00) + ((1+2+3+..i)+j)*Len`.   
和对称矩阵的计算公式一样，不同的是当i小于j时，a(ij)的值是0,没有对应的存储空间。

* 上三角矩阵         
对于上三角矩阵来说，只需存储对角线以上部分和对角线上的元素即可，这些元素的索引为a(ij)(i<=j),仍然采用按行优先 的方式，可以得到每个元素的存储地址为：`add(ij) = add(00) + (n + n-1 + n-2+..+(n-(i-1))+j-i)*Len`，这个公式可以这样理解，先把i行以上的所有行都遍历一遍，因为每行0值有i个，所以计算的时候要将0值的个数减去，当定位到当前的i行时，就加上列数j，但是当前行前面的0值还没处理，所以减去0值的个数i就得到了元素的地址。          


## 带状矩阵及其压缩存储    

现在有一个n*n方阵，如果它的非零元素都集中在一个以主对角线为中心的带状区域中，这个带状区域包含主对角线下面和上面各b条对角线上的元素及主对角线上的元素，就称这个矩阵为半带宽为b的带状矩阵。         

带状矩阵的特点是：对于矩阵元素a(ij)，如果|i-j|>b，说明这个元素不在带状区域内，a(ij)=0,在实际问题中，在带状区域外的值有可能不是0，但是一定是相同的值。    

在带状矩阵内，主对角线两测各有b条对角线相对称，称b为带状矩阵的半带宽，称2b+1为带状矩阵的带宽。     

* 带状矩阵的存储    
带状矩阵存储时只需存储带状区域内的元素，然而在带状区域内的元素的分布也不完全一致，并非每行都是2b+1个元素，前b行和最后几行所含元素都不足2b+1个，只有中间几行有2b+1个元素，但是如果我们按照每行的实际元素个数来分配空间的话，在后面计算各个元素地址的时候会非常复杂，所以为了计算地址时方便，除了第一行和最后一行空间设置为b+1，其余各行都分配2b+1个元素的空间，这样就一共有`(n*(2b+1)-2b)`个存储单元。如果也按照按行优先的方式，可以得到每个元素的存储地址为：`add(ij) = add(00) + ((i*(2b+1)-b) + (j-i+b))*Len`.       
其中，`(i*(2b+1)-b)`表示a(ij)前面i行所有元素的个数，`(j-i+b)`表示在a(ij)所在行前面的元素个数。     



## 稀疏矩阵     

如果一个矩阵中很多元素都为0，而且零元素的数量远远大于非零元素时，称为稀疏矩阵，下面介绍一下稀疏矩阵在计算机中的存储和简单运算。    

* 稀疏矩阵的顺序存储       

因为稀疏矩阵中的零元素较多，如果按照普通矩阵的存储方式存储的话，就会浪费很多空间，所以我们只存储非零元素，而往往只有非零的元素才是有用的信息，因为稀疏矩阵中非零元素的分布并不像对称矩阵、三角矩阵、带状矩阵那样富有规律性，所以我们在存储稀疏矩阵的非零元素时，需要给每个元素附加一些信息来辅助存储。    
稀疏矩阵的存储方式包括：三元组表示法、带辅助行向量的二元组表示法和伪地址表示法，其中三元组表示法最为常用，下面讨论的都是这种方式。     

在矩阵中，要定位一个元素，只需知道它的行数和列数，就像坐标系中知道横纵坐标就可以定位一个点一样，所以用下面这样一个三元组就可以定义一个矩阵中的元素：  
`(i,j,value)`     
其中，i表示该元素所在的行号，j表示该元素所在的列号，value表示该元素的值。       
采用三元组表示法表示稀疏矩阵时，首先将矩阵中的所有非零元素都用上面的三元组形式表示出来，然后按照**行号递增的次序、同一行的非零元素按照列号递增的次序**将所有的三元组存放到连续的存储单元中。     

我们这里举个例子：    

|   B| 0    | 1    |   2   |
|-----|-----|------|-------|
|0    | 行数| 列数 |元素总数|  
|1    | i   |  j   |   value|
|2    |...  | ...  | ...    |
|...  |...  | ...  | ...   |   


这里矩阵B的第一行记录着要存储稀疏矩阵A的行数、列数及所含非零元素的总个数，接下来的每一行均代表A中一个非零元素的三元组表示。      

* 稀疏矩阵A及其对应的三元组表示矩阵B的数据类型定义如下：    
```c
typedef struct {
    int data[100][100]; //存放稀疏矩阵的二维数组
    int m,n; //分别存放稀疏矩阵的行数和列数
} matrix;
typedef int sparseMatrix[100][3]; //表示三元组的类型     
```     

* 将稀疏矩阵转换成对应的三元组表示   
因为稀疏矩阵的三元组表示必须按照以行号递增的顺序、行号相同时按列号递增的次序排列，所以在构建三元组的时候必须按照顺序逐行扫描稀疏矩阵，遇到非零元素就将它们按照顺序写入三元组表示的数组中。    

具体代码实现:    

```c
void compressmatrix(matrix A, sparseMatrix B)
{
    int i,j,k = 1;
    for (i = 0; i < A.m; i++)
        for (j = 0; j < A.n; j++)
            if (A.data[i][j] != 0) //将该非零元素放到三元组表示的数组中去
            {
                B[k][0] = i;
                B[K][1] = j;
                B[K][2] = A.data[i][j];
                k++;
            }

    //三元组数组中第一行存放稀疏矩阵的行数、列数和元素总个数
    B[0][0] = A.m;
    B[0][1] = A.n;
    B[0][2] = k - 1;
}
```         

## 稀疏矩阵的链式存储     

采用十字链表表示
