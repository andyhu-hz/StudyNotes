# 算法的时间复杂度

评价一个算法的优劣，一个重要的指标就是算法的执行时间，如果我们知道一个算法的大致执行时间，我们就能估算出该程序对处理器的实用程度。    

## 时间频度  

一个算法执行所耗费的时间在理论上是不能计算出来的，必须实际测试才能得到准确的结果，但是我们没必要每个程序都去执行得到准确的数值，而且这些数据往往受收到计算机自身硬件条件的影响，所以我们只需要大致知道那些算法需要的时间长，哪些需要的时间短就可以了。一个算法花费的时间和算法中语句的执行次数成正比，一个算法中执行的语句多，它的耗时就长。一个算法中语句的执行次数称为算法的语句频度或时间频度，记为:`T(n)`。

## 时间复杂度 

上面提到的时间频度`T(n)`中，`n`看作是问题的规模，当n不断变化时，时间频度T(n)也会发生变化，如果我们想知道他们的变化规律来做进一步的分析，就需要引入算法时间复杂度的概念。一般情况下，算法的语句执行次数是问题规模n的函数`T(n)`，我们在定义一个辅助函数`f(n)`，使得当问题规模n趋近于无穷大时，`T(n)/f(n)`的极限值为不等于0的常数，这样就称`f(n)`为`T(n)`的数量级函数，记作:`T(n) = O(f(n))`,称为算法的渐进时间复杂度，简称时间复杂度。       

## 大O表示法   

上面用`O()`来表示算法的时间复杂度的方法，成为大O表示法。    

算法时间复杂度应该从最好，最坏，平均三种情况下考虑，由于平均情况大多与最坏情况持平，所以我们一般直接计算最坏情况下的时间复杂度。     

`O(f(n))`中的f(n)可以为1、n、logn、n²等，我们分别将他们称为常数阶，线性阶，对数阶和平方阶，下面来看一下如果推导出来这些函数。       

## 推导大O阶   

先来看几个规则：

* 用1代替运行次数函数中的所有加法常数
* 修改后的运行次数函数中，只保留最高阶项 
* 如果最高阶项存在而且它的系数不是1，则去掉这个系数    



### 常数阶   

先看一个例子：  

```java 
int sum = 1；//执行一次
int n = 100; //执行一次
sum = n * sum; //执行一次
System.out.println(sum); //执行一次
```

上面这段程序的运行次数函数为`f(n) = 4`，根据上面的规则，将常数4改为1，所以时间复杂度为`O(1)`,如果`sum = n * sum`这条语句再执行几十次，但是这并没有影响问题的规模n,所以这个算法的时间复杂度仍为O(1),称为常数阶。   



### 线性阶

线性阶通常是用来描述循环结构的算法时间复杂度，举个例子：  

```java
int num = 0;
for(i = 0; i < n; i++) {
  num += 1;
}
```

上面程序中语句`num += 1`执行了n次，所以算法时间复杂度为O(n)。    



### 对数阶   

```java
int a = 1;
while(a < n) {
  a = a * 2;
  //时间复杂度为O(1)的算法
}
```

上面这段程序,每次循环a都会乘以2，会越来越接近n，当a增加到不小于n时循环结束。假设循环的次数为X，根据

`2 ^ X = n`,得到`X = log2n`,所以这个算法的时间复杂度为`O(logn)`.    



 