# 字符串模式匹配             

## 概念及使用场景              
课本上这么定义的：
>  寻找字符串p在字符串t中个首次出现的起始位置成为字符串的模式匹配，其中，称p为模式(Pattern),t为正文(Text),t的长度远远大于p的长度。            

说白了就是在一个长串中定位一个短字符串，就相当与在一篇文章中挑出一个单词的位置。           

很多计算机软件都有查找的功能，比如浏览器或者word等文本编辑器，当你在使用查找功能时，会要求你输入一个目标字符，这就是概念中的p串，然后计算机就会在当前页面中的这个大字符串也就是t串中寻找p串的位置并进行一些更加高级的操作。           


## 朴素的模式匹配算法(Brute Force)         
简称BF算法，也叫暴力匹配算法。           

* 描述一下过程      


从t串的第n个位置开始与p串进行比较，设置i，j两个标记位置的变量，i标记t串的当前位置，j标记p串的当前位置，比较的时候从两个串的起始位置开始比较，如果起始位置的值相等的话，则两个串同时向下一位开始比较，否则，就使用p(模板)的起始位置与t串的起始位置的下一位开始重新对应进行比较，也就是从t串的n+1位置重新开始，直到出现一次模式串的每一位字符都与t串的连续位置都相同，才算模式匹配成功，然后返回模式串p的第一个字符在长串t中的位置，其他情况就为模式匹配失败。            

* Talk is cheap,show me your code.看一段代码            

```c
int index(String t, int n, String p)
{
    int i = n;
    int j = 1;
    while(i <= t.length && j <= p.length)
    {
        if(t.a[i] == p.a[j])
        {
            i++;
            j++;
        }
        else
        {
            //这个地方是回溯的重点
            i = i - j + 2;
            j = 1;
        }
    }
    if(j > p.length)
    return i - p.length;
    else
    return 0;
}
```         

这段代码其实很好理解，不过需要注意的地方就是我加注释的地方，这里说明一下，当程序执行到这个位置的时候，说明p的下一位和长串中对应位置的值出现了偏差，此时的j表示这次比较的总位数，也就是i相对于第一个位置前进了多少，我们要将i回溯到第二个位置，很容易想到i - j + 1就表示第一个位置，所以要到第二个位置就再加1，也就是i - j + 2.这个细节可以自己在纸上举个例子，模拟一下这个过程，相信应该能理解的。      

* 看一下课本上的代码         

```c
int index(seqstring p, seqstring t)
{
    int i,j, succ;
    //succ为匹配是否成功的标志，当succ = 1时表示成功，succ = 0时表示匹配不成功
    i = 0; succ = 0;
    //这里设置循环条件，i的下标合法并且匹配标志为匹配不成功时继续遍历长串
    while((i <= t.length - p.length) && (!succ))
    {
        j = 0; succ = 1;
        //这个循环用来遍历模板串p，并和t串中对应元素进行比较
        //循环条件为j的下标合法并且前一次标时两个串对应位置的元素相等，这时两个串的下标都推进，继续下一位的比较
        while((j <= p.length - 1) && succ)
          //比较对应位置的元素
          if(p.str[j] == t.str[i + j])
          //如果相等，就推进i和j
          j++;
          //如果不等，则此次匹配失败，退出循环，但是还要将i推进，将j归零，原因和上面一致那段代码一致，就是下次重新比较的准备工作
          else
          succ = 0;
        ++i;  
    }
    if(succ)
    return (i - 1);
    else
    return (-1);
}
```           

这段代码没有指定从t串的第几个位置开始寻找，而是直接从t的第一位开始，下标为0，所以标记两个串的变量i和j都是从0开始的。

* 算法时间复杂度        

该算法的时间复杂度为O(m * n),m为t串的长度，n为p串的长度。        


## 字符串快速模式匹配算法(KMP)    

上面提到的暴力匹配算法虽然也可以达到查找字符串的效果，但是在某些情况，上面的那种方式会有多次的回溯过程，而这种回溯有时候并不是必要的，KMP正是解决了这一问题，而把算法的时间复杂度降低到了O(m+n).        
