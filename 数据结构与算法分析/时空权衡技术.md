# 时空权衡技术    

* 输入增强技术    
* 预构造(使用额外空间)


## 计数排序        

该算法在实际排序时时间复杂度为O(n²)，而且有n的空间复杂度，所以算法效率并不是很好。   

主要步骤是遍历一个序列，统计每个元素对应的比它小的其他元素的个数，假如元素下标是从0开始的，那么全部统计完后，该元素的最终位置就是刚刚统计得到的结果。      

但是该算法也会在某些时刻有发挥空间：  
待排序的元素值来自一个已知的小集合，比如待排序的集合中只有多个1，2元素，那我们就可以使用计数排序方法，扫描列表中1和2的数目，然后重排列就可以了。   

可以推广到更一般的情况，待排序的数组元素有一些其他信息和键值相关，我们可以统计一个已有数列的中各元素的频率，比如绘制一幅图像的直方图。因为这种频率的累积和在统计中称为分布，这个方法也称为"分布计数"。     


## 字符串匹配     

* 蛮力法  
    文本的长度为n，模板的长度为m
    最差效率为O(m*n)，随机文本的平均效率O(n)   

* 输入增强技术   
    * KMP算法      
        从左往右匹配    
    * BM(Boyer-Moore)算法    
        从右往左匹配   


## 散列法    

* 两个要求   
    散列函数需要把键在散列表的单元格中尽可能均匀的分布   
    散列函数必须容易计算   

* 散列的主要版本 
    * 开散列(分离链)   
        hash对应的是下标，如果相同元素很多的话，我们可以将这些相同元素构成一个链表，然后在寻找的时候就可以到这个链表中进行顺序查找。  
        优点是不会出现地址冲突。  
        缺点是如果相同元素非常多，就会增加链表的长度，提高了链表相关操作的时间复杂度。   

    * 闭散列(开式寻址)   
        不产生链表   

## B树   

所有的数据记录都按照键的升序存储在叶子当中，他们的父节点作为索引    
* 每个父母节点包含n-1个升序的键   




