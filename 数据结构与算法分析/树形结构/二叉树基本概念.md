# 二叉树   

Binary Tree是n个结点的有限集合，该集合或者为空，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。    

二叉树定义时要明确子树的次序。   

## 二叉树和树的区别    

* 树的结点个数至少为1，而二叉树的结点个数可以为0.    

* 树中结点的最大度数没有限制，而二叉树的结点最大度数为2.    

* 树分为有序树和无序树，而二叉树一定为有序树。    

## 二叉树的性质      

* 在二叉树的第i层上最多有`2^(i-1)`个结点(i >= 1)      
比如，二叉树的第二层最多有俩个结点，就是`2^(2-1) = 2`。
推广到i个结点就是这个性质了。  


* 深度为k的二叉树最多有`2^k - 1`个结点。   
比如，深度为1的二叉树最多一个结点，就是`2^1 - 1 = 0`。   

* 对任意一棵二叉树，终端结点有n0个，度数为2的结点有n个，则`n0 = n + 1`   

* 具有n个结点的完全二叉树的高度为`log2(n) + 1`。   

* 如果一棵含有n个结点的完全二叉树(深度为log2(n) + 1)按照层次规则(从第一层到log2(n) + 1层，从左到右)编号，那对编号为i的结点有以下性质：    

  * 如果i = 1，则结点i为二叉树的根结点，如果i > 1，则该结点的双亲结点为`i/2`。   

  * 如果2i > n,则结点i没有左孩子，i为一个叶子结点，否则，结点2i就是结点i的左孩子。    

  * 如果2i+1 > n，则结点i没有右孩子，i为一个叶子结点，否则，结点2i+1就是结点i的右孩子。    


## 二叉树的存储结构   

因为二叉树是具有一对多的结点关系，所以在考虑二叉树的存储时不仅要保存结点的信息，还要保存结点之间的关系信息。   

二叉树的存储也可以分为顺序存储和链式存储。    

### 完全二叉树的顺序存储   

上面提到完全二叉树有条性质，就是双亲结点和子女结点的序号关系，根据这个性质，我们简单的使用一维数组将各结点按照次序存储起来，双亲和子女的序号关系自然就变为了数组中索引的关系，这样就能根据索引访问到一个结点的子女结点。     

为了操作方便，结点存储时从数组下标为1的单元开始存储，且完全二叉树的根结点一定位于下标为1的单元中。    

### 一般二叉树的顺序存储    

一般二叉树的各结点之间没有上面的那种性质，所以只靠结点在数组中的下标，没法表示各结点之间的关系，所以我们要给结点结构定义存储结点之间关系的属性，在存储一个结点时，除了存储结点的信息之外，还要增加两个域，分别存放结点的两个子女在数组中的下标。    
具体数据结构定义如下：   

```c
#define MAXSIZE 20
typedef char datatype;
typedef struct {
    datatype data;
    int lchild,rchild; //存放左右孩子在数组中的下标
} node;
node tree[MAXSIZE];
int root; //二叉树的根结点
```   


### 二叉树的链式存储    

上面提到的顺序存储需要先给出数组的大小，采用链式存储就可以解决这个问题。   

链式存储时，每个结点有三个域，分别存放结点的信息data、指向结点左孩子的指针lchild、指向结点右孩子的指针rchild。        

这样就形成了一个二叉链表。    

具体数据结构定义如下：    

```c
typedef char datatype;
typedef struct node {
    datatype data;
    struct node *lchild,*rchild;
} binnode;
typedef binnode *bintree;
bintree root; //指向根结点的指针    
```    

## 二叉树的遍历    

指从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问一次且仅被访问一次。    

二叉树的遍历方式有三种：   

* 前序遍历(根左右)   

* 中序遍历(左根右)    

* 后序遍历(左右根)    

因为二叉树采用的是递归定义，所以遍历算法也可以采用递归方式，每次遍历时都将目标有看作是一棵二叉树。以上三种方式都可以使用递归实现，代码编写比较简单，这里省略。  


* 二叉树的创建算法     

创建二叉树的算法完全可以模仿二叉树遍历的递归算法设计，由于一棵非空的二叉树的前序遍历序列中，第一个结点一定是该二叉树的根结点，接下来就是二叉树左子树的遍历结果，然后就是右字数的遍历结果。      

代码实现前序遍历创建一棵二叉树：    

```c
bintree createbintree()
{
    char ch;
    bintree t;
    if((ch == getchar()) == '#')
        t = NULL;
    else
    {
        t = (bintree*) malloc(sizeof(binnode));
        t -> data = ch;
        t -> lchild = createbintree();
        t -> rchild = createbintree();
    }
    return t;
}
```     

当遍历过程遇到空子树时，就用“#”代替。     

* 利用遍历结果推导二叉树    

有这样一种题目可以检验对二叉树的遍历的熟悉程度。     

`已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，求这棵二叉树的后序遍历结果。`      

* 首先从前序遍历和后序遍历序列入手，因为这两种遍历根结点是在序列开始或结束的地方。

* 然后根据中序遍历序列确定左右子树。         

### 二叉树遍历的非递归实现      

这里我们介绍二叉树的非递归遍历，非递归的算法效率肯定要比递归的效率高。    

* 前序遍历的非递归实现    

前序遍历不管是访问整棵树还是子树，都按照根左右的顺序来访问。所以当访问一棵树t时，先访问t的根结点，当根结点访问结束后一定要把根结点用栈保存起来，然后就该访问它的左子树，然后到栈中弹出刚才保存的根结点，再去访问t的右子树，这里的核心就是在访问一个根结点之后一定要立马把这个根结点入栈保存，不然当左子树遍历完成后，就会找不到遍历右子树的入口了。    

这里我们使用一个栈来保存回溯结点。    

实际代码实现：    

```c
/*先定义一个顺序栈*/
typedef struct stack {
    bintree data[100];
    int tag[100]; //为栈中每个元素设置一个标记，用于后序遍历
    int top; //栈顶指针
} seqstack;

/*入栈*/
void push(seqstack *s, bintree t)
{
    s -> data[s -> top] = t;
    s -> top++;
}

/*出栈*/
bintree pop(seqstack *s)
{
    if(s -> top != 0)
    {
       s -> top--;
       return(s -> data[s -> top]); //返回栈顶结点
    }
    else
        return NULL;
}

/*前序遍历*/
void preorder(bintree t)
{
    seqstack s;
    s.top = 0;
    while((t) || (s.top != 0))//当前处理的子树不为空或栈内还有结点就继续循环遍历
    {
        if(t)
        {
            printf("%c",t -> data);
            push(&s,t);
            t = t -> lchild;
        }
        else //当t=t->lchild后t为空时就说明根结点和左子树已经访问完成
        //应该从栈中弹出保存的根结点，进而访问右子树。    
        {
            t = pop(&s);
            t = t -> rchild;
        }
    }
}

```    


* 中序遍历的非递归实现    

中序遍历不管是对整棵树还是对子树遍历都应该按照左根右的次序进行，当我们访问结点的左孩子时就需要把根结点先入栈保存，然后左孩子访问结束后，就去栈中弹出根结点，进行访问根结点和右子树，和前序遍历的区别就是保存根结点的时机不同。   

具体代码实现：   

```c
void midorder(bintree t)
{
    seqstack s;
    s.top = 0;
    while(t || (s.top != 0))
    {
        if(t)
        {
            push(&s,t); //先保存根结点
            t = t -> lchild;
        }
        else
        {
            t = pop(&s);
            printf("%c",t -> data);
            t = t -> rchlid;
        }
    }
}
```    

这段代码有一个小疑惑，就是最开始的时候并没有if里面打印t的左结点的值，这是因为我们一开始是对树的根结点进行操作的，我们需要先把根结点和左结点都压入栈中，而且是先把根结点压入栈中，这样当左结点的左子树为空时，就可以先弹出左结点进行访问，然后再弹出根结点进行访问，形成这样的先左后根的顺序。      

当栈中元素弹出后，意味着其左子树已经访问完成，出栈后应立即访问其根结点，再进入其右子树进行访问。    



* 后序遍历的非递归实现     

后序遍历不管是对整棵树还是对子树遍历都应该按照左右根的次序进行，所以当我们访问一棵树t时，先进入到t的左子树访问，此时t的右子树和根结点尚未访问，所以应将t入栈保存，当左子树访问完成后，从栈中弹出t，对其右子树和根结点进行访问，但是这里需要注意，当一个根结点位于栈顶时，如果它的右子树不为空而且没有被访问过，那这时这个根结点是不能出栈的，只有当它的右子树访问完成后，这个根结点才能出栈被访问。     

所以我们这里对栈中的每个元素都做一个标记，当标记为0时，表示应该访问它右子树，这时把右子树作为当前处理的对象，然后把标记改为1。   

当右子树访问完成后，该结点有一次位于栈顶，标记为1，这时将其出栈，访问其值。    


具体代码实现：   

```c
void postorder(bintree t)
{
    seqstack s;
    s.top = 0;
    while(t || s.top != 0)
    {
        if(t)
        {
            s.data[s.top] = t;
            s.tag[s.top] = 0;
            s.top++;
            t = t -> lchildl;
        }
        else
        {
            if(s.tag[s.top - 1] == 1)
            {
                s.top--;
                t = s.data[s.top];
                printf("%c",t -> data);
                t = NULL;
            }
            else
            {
                t = s.data[s.top - 1];
                s.tag[s.top - 1] = 1;
                t = t -> rchild;
            }
        }
    }
}
```    

## 二叉树的查找   

返回二叉树t中值为x的结点的指针
```c
bintree locate(bintree t,datatype x)
{
    bintree p;
    if(!t) return NULL;
    else
    {   //从左右子树分别查找
        p = locate(t -> lchild,x);
        if(p) return p;
        else  return p = locate(t -> rchild,x);
    }
}   
```   

## 求二叉树中的结点个数   

```c
int numbintree(bintree t)
{
    if(!t) return 0;
    else return (numbintree(t -> lchild) + numbintree(t -> rchild) + 1);
}
```    


## 求二叉树的高度    

```c
int heightbintree(bintree t)
{
    int i,j;
    if(!t) return 0;
    else
    {
        i = heightbintree(t -> lchild);
        j = heightbintree(t -> rchlid);
        return (i > j) ? i + 1 : j + 1;
    }
}
```    
