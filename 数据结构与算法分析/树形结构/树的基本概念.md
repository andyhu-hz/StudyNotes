# 树的定义    
树是n个结点的有限集合，n=0时称为空树。在任意一棵非空树中：    
* 有且仅有一个特定的结点称为根       

* 当n>1时,其余结点可分为m(m>0)个互不相交的有限集合，其中每个集合本身又是一棵树，并且称为根的子树。    

这是对树的一个递归定义。树可以表示一种一对多的数据结构。    

## 结点分类   
树中结点也有多种，结点拥有的子树个数称为结点的度，度为0的结点称为叶子结点或终端结点，树的度是树内各结点的度的最大值。    

## 结点之间的关系    

结点的子树称为该结点的孩子，相应的，该结点称为孩子的双亲，同一个双亲的孩子之间称为兄弟。    

结点的祖先是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的子孙。    


## 树的其他概念    

* 结点的层次    
根为第一层，根的孩子为第二层。   
树中结点的最大层次为树的深度或高度。    


* 树的有序性   
如果将树中的各子树看成从左向右是有次序的，不能互换的，则该树为有序的，否则为无序的。    


* 森林    
森林是m棵互不相交的树的集合，对树中的每个结点来说，其子树的集合就是森林。   


## 树的存储结构    

说到存储结构，很自然会想到顺序存储或链式存储，但是如果我们想用顺序结构来存储树这种一对多的结构，好像不是那么合适。  

简单的顺序存储是不能满足对树的存储，不过合理利用顺序结构和链式结构就可以设计出对树的存储结构，下面介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。   

### 双亲表示法   

在一棵树中，除了根没有双亲之外，其余任何结点都有且只有一个双亲，根据这个性质，我们在存储树的结点时，应该给每个结点设置两个信息，一个是结点的数据信息，一个就是描述结点和其双亲结点的地址关系，所以我们给结点设置两个域，一个域是数据域data，一个域是指针域parent，存储该结点双亲在数组的下标。   

描述树的结构体定义如下：   

```c
#define MAXSIZE 100
typedef char datatype;
typedef struct node {
  datatype data;
  int parent; //结点双亲在数组的下标
} node;

typedef struct tree {
  node treelist[MAXSIZE];
  int length,root; //树中结点的个数和根的位置
} tree; //树的类型
```   
我们规定，根结点的位置域为-1.    

### 孩子表示法    
