# 树的定义    
树是n个结点的有限集合，n=0时称为空树。在任意一棵非空树中：     

* 有且仅有一个特定的结点称为根       

* 当n>1时,其余结点可分为m(m>0)个互不相交的有限集合，其中每个集合本身又是一棵树，并且称为根的子树。    

这是对树的一个递归定义。树可以表示一种一对多的数据结构。    

## 结点分类   
树中结点也有多种，结点拥有的子树个数称为结点的度，度为0的结点称为叶子结点或终端结点，树的度是树内各结点的度的最大值。    

## 结点之间的关系    

结点的子树称为该结点的孩子，相应的，该结点称为孩子的双亲，同一个双亲的孩子之间称为兄弟。    

结点的祖先是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的子孙。     

一棵具有n个结点的树，该树中所有结点的度数之和为`n-1`。   


## 树的其他概念    

* 结点的层次    
根为第一层，根的孩子为第二层。   
树中结点的最大层次为树的深度或高度。    


* 树的有序性   
如果将树中的各子树看成从左向右是有次序的，不能互换的，则该树为有序的，否则为无序的。    


* 森林    
森林是m棵互不相交的树的集合，对树中的每个结点来说，其子树的集合就是森林。   


## 树的存储结构    

说到存储结构，很自然会想到顺序存储或链式存储，但是如果我们想用顺序结构来存储树这种一对多的结构，好像不是那么合适。  

简单的顺序存储是不能满足对树的存储，不过合理利用顺序结构和链式结构就可以设计出对树的存储结构，下面介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。   

### 双亲表示法   

在一棵树中，除了根没有双亲之外，其余任何结点都有且只有一个双亲，根据这个性质，我们在存储树的结点时，应该给每个结点设置两个信息，一个是结点的数据信息，一个就是描述结点和其双亲结点的地址关系，所以我们给结点设置两个域，一个域是数据域data，一个域是指针域parent，存储该结点双亲在数组的下标。   

描述树的结构体定义如下：   

```c
#define MAXSIZE 100
typedef char datatype;
typedef struct node {
  datatype data;
  int parent; //结点双亲在数组的下标
} node;

typedef struct tree {
  node treelist[MAXSIZE];
  int length,root; //树中结点的个数和根的位置
} tree; //树的类型
```   
我们规定，根结点的位置域为-1.    

### 孩子表示法    

* 指针方式的孩子表示法    

与双亲表示法不同的是，使用孩子表示法表示树时，每个结点需要保存其孩子的位置，所以结点定义时包含两个域，一个是值域data，另一个是指针数组，数组中的每个元素都是指向该结点孩子的指针，这个指针数组的大小就是树的度。     

具体数据结构定义如下：    

```c
#define m 3 //树的度数
typedef char datatype;
typedef struct node {
    datatype data;
    struct node *child[m]; //指向孩子的指针数组
} node, *tree;
tree node; //指向根结点的指针
```   

这样就通过指向子女的指针数组把所有的结点都联系在一起了。   

* 数组方式的孩子表示法   

我们可以把树中的所有结点都存储到一个一维数组中，这样每个结点就会有一个下标，我们在定义结点的时候，就可以把指针数组换成普通数组，直接存储孩子结点的下标。       

具体的数据结构定义如下，可以对比于上面指针方式的孩子表示法：    

```c
#define m 3 //树的度
#define MAXSIZE 100 //树中结点的最大值
typedef char datatype;  
typedef struct node {
    datatype data;
    int child[m]; //存放结点孩子在数组中的下标
} treeNode;
treeNode tree[MAXSIZE]; //存放树结点的数组
int root;
int length;   

```     

* 链表方式的孩子表示法    

上面两种方式每个结点中都含有一个child数组，里面分别存放指向孩子的指针或者下标，而且这个数组的长度都是m，就是树的度，我们说树的度是树中所有结点中拥有子树最多的数量，这就会造成一定程度上的空间浪费，有的结点可能并没有m个子树。     

为了解决这种浪费空间的问题，我们可以把每个结点的子女链成一个单链表，这样n个结点就有n个单链表，再把每个单链表的头指针存放到一个一维数组中，这样，通过在数组中找到链表的头指针，在到链表中去访问其他结点。这种方式又称为链表方式的孩子表示法。   

具体数据结构定义如下：   

```c
#define MAXSIZE 50
typedef char datatype;
typedef struct chnode {
    int child;
    struct chnode *next;
} chnode, *chpoint;

typedef struct {
    datatype data;
    chpoint firstchild; //指向第一个子女的指针
} node;

typedef struct {
    node treelist[MAXSIZE];
    int length,root;
} tree;
```   

### 孩子兄弟表示法    

这种方式结点中除了存储结点的值外，还有两个指针域，firstchild和rightbrother,分别指向该结点的第一个孩子和右兄弟。这样就形成了一个二叉链表，这种方式也称为二叉树表示法。    

具体数据结构定义如下：   

```c
typedef char datatype;
typedef struct node {
    datatype data;
    struct node *firstchild,*rightbrother;
} node, *pnode;
pnode root; //指向根结点的指针   
```    

## 树的遍历     

对树的遍历就是对树中的每个结点按照一定的次序全部访问一遍。    

树的常用遍历方式分为以下三种：   

* 前序遍历
根左右   

* 后序遍历
左右根

* 层次遍历   
按照树的层次从左向右遍历   

* 对指针方式孩子表示法存储的树进行递归前序遍历   

```c
/*参数为指向树根结点的指针*/
void preorder(tree p)
{
    int i;
    if (p != NULL)
    {
        printf("%c",p -> data); //先访问根结点
        for (i = 0; i < m; i++)
            preorder(p -> child[i]); //访问孩子结点
    }
}
```    

* 对指针方式孩子表示法存储的树的递归后序遍历   

```c
void postorder(tree p)
{
    int i;
    if (p != NULL)
    {
        for (i = 0; i < m; i++)
            postorder(p -> child[i]); //先访问孩子结点
        printf("%c",p -> data);
    }
}
```

* 对指针方式孩子表示法存储的树的层次遍历   

层次遍历一棵树时，先访问第一层的结点，就是根结点，然后按照从左到右的次序访问第二层的结点，而第二层的结点就是第一层根结点的子女，然后访问第三层中的所有结点，而第三层结点又是第二层结点的子女。所以在树的层次遍历中，当某一层的每个结点被访问后，应该马上将其子女结点都按照从左到右的次序存放起来，因为当这一层的所有结点都被访问后就轮到它们各自的子女结点。这里我们使用队结构来存放这些子女结点。   

每次访问一个结点时只需弹出队首的结点即可，访问完成后，若其子女非空，则将其子女按照顺序入队，不断重复这个操作，直到队列为空。     

代码实现：   

```c
void levelorder(tree p)
{
    tree queue[100]; //存放待访问结点的队列
    int f,r,i; //f，r为队首队尾指针
    f = 0;
    r = 1;
    tree p;
    queue[0] = t; //根结点入队
    while (f < r) //队列不为空
    {
        p = queue[f];
        f++;
        printf("%c",p -> data); //访问队首元素
        for (i = 0; i < m; i++) //将队首结点的子女按照次序入队
        {
            if (p -> child[i])
                queue[r] = p -> child[i];
                ++r;
        }
    }
}
```
